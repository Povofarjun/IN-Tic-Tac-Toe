<!-- index.html - Infinity Tic Tac Toe (Enhanced UI/UX with Canvas, Win Logic & Infinity Mode) -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Infinity Tic Tac Toe - Enhanced UI with Win Detection</title>
  <style>
    /* Enhanced styling inspired by provided UI/UX references */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #74ABE2, #5563DE);
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      color: #fff;
    }
    h1 {
      margin: 20px 0;
      font-size: 2.5rem;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    canvas {
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      cursor: pointer;
      transition: transform 0.2s ease;
    }
    canvas:hover {
      transform: scale(1.02);
    }
    #status {
      margin-top: 20px;
      font-size: 1.5rem;
      font-weight: bold;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
    }
    #resetButton {
      margin-top: 15px;
      padding: 10px 25px;
      font-size: 1rem;
      border: none;
      border-radius: 5px;
      background: #5563DE;
      color: #fff;
      cursor: pointer;
      transition: background 0.3s ease;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    #resetButton:hover {
      background: #4452c4;
    }
  </style>
</head>
<body>
  <h1>Infinity Tic Tac Toe</h1>
  <canvas id="gameCanvas" width="300" height="300"></canvas>
  <div id="status">Current Player: X</div>
  <button id="resetButton">Reset Game</button>
  <script>
    // Enhanced Canvas Game Code for Infinity Tic Tac Toe with Win Detection
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const statusDiv = document.getElementById('status');
    const resetButton = document.getElementById('resetButton');

    // Game state:
    // board: array of 9 cells, each cell is either null or { player: 'X'|'O', faded: boolean }
    // movesX/movesO: track the order of moves for each player to manage fading logic.
    let board = Array(9).fill(null);
    let movesX = [];
    let movesO = [];
    let currentPlayer = 'X';
    let gameOver = false; // When true, further moves are disabled

    // Winning combinations for 3x3 Tic Tac Toe
    const winCombinations = [
      [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
      [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
      [0, 4, 8], [2, 4, 6]             // Diagonals
    ];

    // Check for a win; returns 'X' or 'O' if win condition is met, otherwise null.
    function checkWin() {
      for (const combination of winCombinations) {
        const [a, b, c] = combination;
        if (board[a] && board[b] && board[c]) {
          if (board[a].player === board[b].player && board[a].player === board[c].player) {
            return board[a].player;
          }
        }
      }
      return null;
    }

    // Draw the grid with enhanced visual style
    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.lineWidth = 4;
      ctx.strokeStyle = '#333';
      ctx.beginPath();
      // Vertical lines
      ctx.moveTo(100, 0);
      ctx.lineTo(100, 300);
      ctx.moveTo(200, 0);
      ctx.lineTo(200, 300);
      // Horizontal lines
      ctx.moveTo(0, 100);
      ctx.lineTo(300, 100);
      ctx.moveTo(0, 200);
      ctx.lineTo(300, 200);
      ctx.stroke();
    }

    // Draw moves with color, shadows, and fade effects
    function drawMoves() {
      for (let i = 0; i < 9; i++) {
        const cell = board[i];
        if (cell !== null) {
          const col = i % 3;
          const row = Math.floor(i / 3);
          const centerX = col * 100 + 50;
          const centerY = row * 100 + 50;
          ctx.save();
          ctx.globalAlpha = cell.faded ? 0.5 : 1.0;
          ctx.font = 'bold 48px Segoe UI';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          // Modern shadow effect
          ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
          ctx.shadowBlur = 4;
          ctx.shadowOffsetX = 2;
          ctx.shadowOffsetY = 2;
          ctx.fillStyle = cell.player === 'X' ? '#E74C3C' : '#2ECC71';
          ctx.fillText(cell.player, centerX, centerY);
          ctx.restore();
        }
      }
    }

    // Update canvas by redrawing grid and moves
    function updateCanvas() {
      drawGrid();
      drawMoves();
    }

    // Convert mouse click coordinates to board cell index (0-8)
    function getCellFromCoordinates(x, y) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const canvasX = (x - rect.left) * scaleX;
      const canvasY = (y - rect.top) * scaleY;
      const col = Math.floor(canvasX / 100);
      const row = Math.floor(canvasY / 100);
      return row * 3 + col;
    }

    // Process a move when a cell is clicked
    function makeMove(index) {
      if (gameOver) return; // Disable moves if game is over

      // Process move if cell is empty
      if (board[index] === null) {
        board[index] = { player: currentPlayer, faded: false };
        if (currentPlayer === 'X') {
          movesX.push(index);
          // Fade the oldest move on the 4th move for player X
          if (movesX.length === 4) {
            const fadeIndex = movesX[0];
            if (board[fadeIndex]) board[fadeIndex].faded = true;
          }
        } else {
          movesO.push(index);
          // Fade the oldest move on the 4th move for player O
          if (movesO.length === 4) {
            const fadeIndex = movesO[0];
            if (board[fadeIndex]) board[fadeIndex].faded = true;
          }
        }
        // Remove the opponent's faded move if conditions are met
        if (currentPlayer === 'X' && movesX.length === 4 && movesO.length >= 4) {
          const fadeIndex = movesO[0];
          if (board[fadeIndex] && board[fadeIndex].faded) {
            board[fadeIndex] = null;
            movesO.shift();
          }
        }
        if (currentPlayer === 'O' && movesO.length === 4 && movesX.length >= 4) {
          const fadeIndex = movesX[0];
          if (board[fadeIndex] && board[fadeIndex].faded) {
            board[fadeIndex] = null;
            movesX.shift();
          }
        }
        // Switch current player
        currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
        statusDiv.textContent = `Current Player: ${currentPlayer}`;
        updateCanvas();
      } else {
        // Allow capturing of a faded opponent's move
        if (board[index].faded && board[index].player !== currentPlayer) {
          const opponent = board[index].player;
          board[index] = { player: currentPlayer, faded: false };
          if (opponent === 'X') {
            const pos = movesX.indexOf(index);
            if (pos > -1) movesX.splice(pos, 1);
          } else {
            const pos = movesO.indexOf(index);
            if (pos > -1) movesO.splice(pos, 1);
          }
          if (currentPlayer === 'X') {
            movesX.push(index);
            if (movesX.length === 4) {
              const fadeIndex = movesX[0];
              if (board[fadeIndex]) board[fadeIndex].faded = true;
            }
          } else {
            movesO.push(index);
            if (movesO.length === 4) {
              const fadeIndex = movesO[0];
              if (board[fadeIndex]) board[fadeIndex].faded = true;
            }
          }
          currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
          statusDiv.textContent = `Current Player: ${currentPlayer}`;
          updateCanvas();
        }
      }

      // Check for win after each move
      const winner = checkWin();
      if (winner) {
        statusDiv.textContent = `Player ${winner} wins!`;
        gameOver = true;
      }
    }

    // Reset game state and redraw the board
    function resetGame() {
      board = Array(9).fill(null);
      movesX = [];
      movesO = [];
      currentPlayer = 'X';
      gameOver = false;
      statusDiv.textContent = `Current Player: ${currentPlayer}`;
      updateCanvas();
    }

    // Event listeners for canvas clicks and reset button
    canvas.addEventListener('click', (e) => {
      const index = getCellFromCoordinates(e.clientX, e.clientY);
      makeMove(index);
    });
    resetButton.addEventListener('click', resetGame);

    // Initial drawing of the game board
    updateCanvas();
  </script>
</body>
</html>
