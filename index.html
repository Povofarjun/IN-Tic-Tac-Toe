<!-- index.html - Infinity Tic Tac Toe (Enhanced UI/UX with Canvas, Win Detection, AI Mode, and Mode Selection) -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Infinity Tic Tac Toe - Enhanced UI with AI Mode</title>
  <style>
    /* Enhanced styling inspired by provided UI/UX references */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #74ABE2, #5563DE);
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      color: #fff;
    }
    h1 {
      margin: 20px 0;
      font-size: 2.5rem;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    canvas {
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      cursor: pointer;
      transition: transform 0.2s ease;
    }
    canvas:hover {
      transform: scale(1.02);
    }
    #status {
      margin-top: 20px;
      font-size: 1.5rem;
      font-weight: bold;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
    }
    #resetButton {
      margin-top: 15px;
      padding: 10px 25px;
      font-size: 1rem;
      border: none;
      border-radius: 5px;
      background: #5563DE;
      color: #fff;
      cursor: pointer;
      transition: background 0.3s ease;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    #resetButton:hover {
      background: #4452c4;
    }
    /* Modal overlay for mode selection */
    #modeSelection {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #modeSelectionContent {
      background: #fff;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      color: #333;
    }
    #modeSelectionContent h2 {
      margin-bottom: 20px;
    }
    #modeSelectionContent button {
      margin: 10px;
      padding: 10px 20px;
      font-size: 1rem;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background: #5563DE;
      color: #fff;
      transition: background 0.3s ease;
    }
    #modeSelectionContent button:hover {
      background: #4452c4;
    }
  </style>
</head>
<body>
  <h1>Infinity Tic Tac Toe</h1>
  <canvas id="gameCanvas" width="300" height="300"></canvas>
  <div id="status">Current Player: X</div>
  <button id="resetButton" style="display:none;">Reset Game</button>

  <!-- Mode selection modal -->
  <div id="modeSelection">
    <div id="modeSelectionContent">
      <h2>Select Game Mode</h2>
      <button id="btnPVP">Play with Player</button>
      <button id="btnAI">Play with AI</button>
    </div>
  </div>

  <script>
    // Enhanced Canvas Game Code for Infinity Tic Tac Toe with Win Detection, AI Mode, and Mode Selection
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const statusDiv = document.getElementById('status');
    const resetButton = document.getElementById('resetButton');
    const modeSelection = document.getElementById('modeSelection');
    const modeSelectionContent = document.getElementById('modeSelectionContent');

    let board = Array(9).fill(null); // Each cell: { player: 'X'|'O', faded: boolean }
    let movesX = [];
    let movesO = [];
    let currentPlayer = 'X';
    let gameOver = false;
    let gameMode = null; // "pvp" or "ai"

    // Winning combinations for 3x3 Tic Tac Toe
    const winCombinations = [
      [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
      [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
      [0, 4, 8], [2, 4, 6]             // Diagonals
    ];

    // Check for win; returns 'X' or 'O' if win condition is met, otherwise null.
    function checkWin() {
      for (const combination of winCombinations) {
        const [a, b, c] = combination;
        if (board[a] && board[b] && board[c]) {
          if (board[a].player === board[b].player && board[a].player === board[c].player) {
            return board[a].player;
          }
        }
      }
      return null;
    }

    // Draw grid with enhanced visual style
    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.lineWidth = 4;
      ctx.strokeStyle = '#333';
      ctx.beginPath();
      // Vertical lines
      ctx.moveTo(100, 0);
      ctx.lineTo(100, 300);
      ctx.moveTo(200, 0);
      ctx.lineTo(200, 300);
      // Horizontal lines
      ctx.moveTo(0, 100);
      ctx.lineTo(300, 100);
      ctx.moveTo(0, 200);
      ctx.lineTo(300, 200);
      ctx.stroke();
    }

    // Draw moves with color, shadows, and fade effects
    function drawMoves() {
      for (let i = 0; i < 9; i++) {
        const cell = board[i];
        if (cell !== null) {
          const col = i % 3;
          const row = Math.floor(i / 3);
          const centerX = col * 100 + 50;
          const centerY = row * 100 + 50;
          ctx.save();
          ctx.globalAlpha = cell.faded ? 0.5 : 1.0;
          ctx.font = 'bold 48px Segoe UI';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          // Modern shadow effect
          ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
          ctx.shadowBlur = 4;
          ctx.shadowOffsetX = 2;
          ctx.shadowOffsetY = 2;
          ctx.fillStyle = cell.player === 'X' ? '#E74C3C' : '#2ECC71';
          ctx.fillText(cell.player, centerX, centerY);
          ctx.restore();
        }
      }
    }

    // Update canvas by redrawing grid and moves
    function updateCanvas() {
      drawGrid();
      drawMoves();
    }

    // Convert mouse click coordinates to board cell index (0-8)
    function getCellFromCoordinates(x, y) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const canvasX = (x - rect.left) * scaleX;
      const canvasY = (y - rect.top) * scaleY;
      const col = Math.floor(canvasX / 100);
      const row = Math.floor(canvasY / 100);
      return row * 3 + col;
    }

    // Get list of valid moves for AI: empty cells or faded opponent cells
    function getValidMoves() {
      let valid = [];
      for (let i = 0; i < 9; i++) {
        if (board[i] === null) {
          valid.push(i);
        } else if (board[i] && board[i].faded && board[i].player !== currentPlayer) {
          valid.push(i);
        }
      }
      return valid;
    }

    // AI move: choose a random valid move
    function aiMove() {
      if (gameOver) return;
      const validMoves = getValidMoves();
      if (validMoves.length === 0) return;
      const randomIndex = Math.floor(Math.random() * validMoves.length);
      const move = validMoves[randomIndex];
      setTimeout(() => {
        makeMove(move);
      }, 500);
    }

    // Process a move when a cell is clicked or chosen by AI
    function makeMove(index) {
      if (gameOver) return; // Disable moves if game is over

      // Process move if cell is empty
      if (board[index] === null) {
        board[index] = { player: currentPlayer, faded: false };
        if (currentPlayer === 'X') {
          movesX.push(index);
          // Fade the oldest move on the 3rd move for player X
          if (movesX.length === 3) {
            const fadeIndex = movesX[0];
            if (board[fadeIndex]) board[fadeIndex].faded = true;
          }
        } else {
          movesO.push(index);
          // Fade the oldest move on the 3rd move for player O
          if (movesO.length === 3) {
            const fadeIndex = movesO[0];
            if (board[fadeIndex]) board[fadeIndex].faded = true;
          }
        }
        // Remove the opponent's faded move if conditions are met
        if (currentPlayer === 'X' && movesX.length === 3 && movesO.length >= 3) {
          const fadeIndex = movesO[0];
          if (board[fadeIndex] && board[fadeIndex].faded) {
            board[fadeIndex] = null;
            movesO.shift();
          }
        }
        if (currentPlayer === 'O' && movesO.length === 3 && movesX.length >= 3) {
          const fadeIndex = movesX[0];
          if (board[fadeIndex] && board[fadeIndex].faded) {
            board[fadeIndex] = null;
            movesX.shift();
          }
        }
        // Switch current player
        currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
        statusDiv.textContent = `Current Player: ${currentPlayer}`;
        updateCanvas();
      } else {
        // Allow capturing of a faded opponent's move
        if (board[index].faded && board[index].player !== currentPlayer) {
          const opponent = board[index].player;
          board[index] = { player: currentPlayer, faded: false };
          if (opponent === 'X') {
            const pos = movesX.indexOf(index);
            if (pos > -1) movesX.splice(pos, 1);
          } else {
            const pos = movesO.indexOf(index);
            if (pos > -1) movesO.splice(pos, 1);
          }
          if (currentPlayer === 'X') {
            movesX.push(index);
            if (movesX.length === 3) {
              const fadeIndex = movesX[0];
              if (board[fadeIndex]) board[fadeIndex].faded = true;
            }
          } else {
            movesO.push(index);
            if (movesO.length === 3) {
              const fadeIndex = movesO[0];
              if (board[fadeIndex]) board[fadeIndex].faded = true;
            }
          }
          currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
          statusDiv.textContent = `Current Player: ${currentPlayer}`;
          updateCanvas();
        }
      }

      // Check for win after each move
      const winner = checkWin();
      if (winner) {
        statusDiv.textContent = `Player ${winner} wins!`;
        gameOver = true;
        setTimeout(() => {
          showModeSelection(`Player ${winner} wins!<br>Select Game Mode:`);
        }, 1000);
      } else {
        // If in AI mode and it's AI's turn, trigger AI move
        if (!gameOver && gameMode === 'ai' && currentPlayer === 'O') {
          aiMove();
        }
      }
    }

    // Reset game state and redraw the board
    function resetGame() {
      board = Array(9).fill(null);
      movesX = [];
      movesO = [];
      currentPlayer = 'X';
      gameOver = false;
      statusDiv.textContent = `Current Player: ${currentPlayer}`;
      updateCanvas();
    }

    // Show mode selection modal with a custom message (if provided)
    function showModeSelection(message) {
      modeSelectionContent.innerHTML = `<h2>${message || 'Select Game Mode'}</h2>
        <button id="btnPVP">Play with Player</button>
        <button id="btnAI">Play with AI</button>`;
      modeSelection.style.display = 'flex';
      document.getElementById('btnPVP').addEventListener('click', () => {
        gameMode = 'pvp';
        hideModeSelection();
        resetGame();
      });
      document.getElementById('btnAI').addEventListener('click', () => {
        gameMode = 'ai';
        hideModeSelection();
        resetGame();
      });
    }

    function hideModeSelection() {
      modeSelection.style.display = 'none';
    }

    // Handle canvas click events for human moves
    canvas.addEventListener('click', (e) => {
      // In AI mode, only allow human moves when it's human's turn (X)
      if (gameMode === 'ai' && currentPlayer !== 'X') return;
      const index = getCellFromCoordinates(e.clientX, e.clientY);
      makeMove(index);
    });

    // Hide the reset button (we use modal for restarting)
    resetButton.addEventListener('click', resetGame);

    // Initial drawing of the game board
    updateCanvas();

    // Show mode selection modal on page load
    showModeSelection();
  </script>
</body>
</html>
