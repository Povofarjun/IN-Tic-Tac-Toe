<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Enhanced Infinity Tic Tac Toe: Minimalist Futuristic UI -->
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Enhanced Infinity Tic Tac Toe</title>
  <!-- Import futuristic font -->
  <link href="https://fonts.googleapis.com/css2?family=Orbitron&display=swap" rel="stylesheet">
  <style>
    /* Global Reset and Fullscreen Layout */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden; /* No scroll on any size */
      height: 100%;
      font-family: 'Orbitron', sans-serif;
      background: linear-gradient(135deg, #74ABE2, #5563DE);
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    :root {
      --primary-color: #5563DE;
      --accent-color: #4452c4;
      --background-start: #74ABE2;
      --background-end: #5563DE;
      --x-color: #E74C3C;
      --o-color: #2ECC71;
    }
    .dark-mode {
      --background-start: #2c3e50;
      --background-end: #1a1a1a;
      color: #fff;
    }
    /* Minimalist Container */
    .game-container {
      width: 100vw;
      height: 100vh;
      max-width: 600px;
      max-height: 600px;
      padding: 20px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-evenly;
      background: rgba(0,0,0,0.05);
    }
    h1 {
      margin: 0;
      font-size: 2rem;
      text-align: center;
      background: linear-gradient(45deg, #fff, #e6e6e6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    canvas {
      background: #fff;
      border-radius: 15px;
      width: 100%;
      height: auto;
      max-width: 400px;
      max-height: 400px;
      cursor: pointer;
      transition: transform 0.2s ease;
    }
    canvas:hover {
      transform: scale(1.02);
    }
    /* Minimalist Oval Buttons */
    .controls, .difficulty-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .button {
      padding: 10px 20px;
      font-size: 1rem;
      border: none;
      border-radius: 50px;
      background: var(--primary-color);
      color: #fff;
      cursor: pointer;
      transition: all 0.3s ease;
      outline: none;
    }
    .button:hover {
      background: var(--accent-color);
    }
    .button:active {
      transform: translateY(1px);
    }
    .button.undo {
      background: #e74c3c;
    }
    .button.undo:hover {
      background: #c0392b;
    }
    #status {
      font-size: 1.2rem;
      text-align: center;
      margin: 10px 0;
      min-height: 1.5em;
    }
    .score-board {
      display: flex;
      gap: 30px;
      justify-content: center;
    }
    .score-item {
      text-align: center;
    }
    .score-label {
      font-size: 1rem;
      margin-bottom: 3px;
      opacity: 0.8;
    }
    .score-value {
      font-size: 1.5rem;
      font-weight: bold;
    }
    /* Modal Styling: Minimalist */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease;
    }
    .modal.active {
      opacity: 1;
      visibility: visible;
    }
    .modal-content {
      background: #fff;
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      color: #333;
      max-width: 90%;
      width: 300px;
    }
    .modal h2 {
      margin-bottom: 20px;
    }
    /* Settings and Sound Toggle */
    .settings-icon, .sound-toggle {
      position: fixed;
      top: 20px;
      background: rgba(0,0,0,0.3);
      border: none;
      color: #fff;
      padding: 10px;
      border-radius: 50%;
      cursor: pointer;
      transition: background 0.3s ease;
      outline: none;
      font-size: 1.2rem;
    }
    .settings-icon {
      right: 20px;
    }
    .sound-toggle {
      left: 20px;
    }
    .settings-icon:hover, .sound-toggle:hover {
      background: rgba(0,0,0,0.5);
    }
  </style>
</head>
<body>
  <button class="settings-icon" onclick="toggleSettings()">‚öôÔ∏è</button>
  <button class="sound-toggle" onclick="toggleSound()">üîä</button>
  
  <div class="game-container">
    <h1>Infinity Tic Tac Toe</h1>
    <div class="score-board">
      <div class="score-item">
        <div class="score-label">Player X</div>
        <div class="score-value" id="scoreX">0</div>
      </div>
      <div class="score-item">
        <div class="score-label">Player O</div>
        <div class="score-value" id="scoreO">0</div>
      </div>
    </div>
    <canvas id="gameCanvas" width="300" height="300"></canvas>
    <div id="status">Current Player: X</div>
    <div class="controls">
      <button class="button undo" onclick="undoMove()" id="undoButton">Undo</button>
      <button class="button" onclick="resetGame()">Reset</button>
    </div>
  </div>

  <!-- Mode Selection Modal -->
  <div id="modeSelection" class="modal">
    <div class="modal-content">
      <h2>Select Game Mode</h2>
      <button class="button" onclick="selectMode('pvp')">Play PvP</button>
      <button class="button" onclick="showDifficultySelection()">Play vs AI</button>
    </div>
  </div>

  <!-- Difficulty Selection Modal -->
  <div id="difficultySelection" class="modal">
    <div class="modal-content">
      <h2>Select Difficulty</h2>
      <div class="difficulty-buttons">
        <button class="button" onclick="selectDifficulty('easy')">Easy</button>
        <button class="button" onclick="selectDifficulty('medium')">Medium</button>
        <button class="button" onclick="selectDifficulty('hard')">Hard</button>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div id="settingsModal" class="modal">
    <div class="modal-content">
      <h2>Settings</h2>
      <button class="button" onclick="toggleDarkMode()">Toggle Dark Mode</button>
      <button class="button" onclick="toggleSound()">Toggle Sound</button>
      <button class="button" onclick="hideSettings()">Close</button>
    </div>
  </div>

  <script>
    /********************************************************************
     * Global Game State and Variables
     ********************************************************************/
    let gameState = {
      board: Array(9).fill(null),
      movesX: [],
      movesO: [],
      currentPlayer: 'X',
      gameOver: false
    };

    let moveHistory = [];
    let gameMode = null;
    let difficulty = 'medium';
    let scores = { X: 0, O: 0 };
    let soundEnabled = true;
    let isDarkMode = false;

    const moveSound = new Audio('data:audio/wav;base64,UklGRl9vAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU...');
    const winSound = new Audio('data:audio/wav;base64,UklGRl9vAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU...');

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const statusDiv = document.getElementById('status');

    const winCombinations = [
      [0, 1, 2], [3, 4, 5], [6, 7, 8],
      [0, 3, 6], [1, 4, 7], [2, 5, 8],
      [0, 4, 8], [2, 4, 6]
    ];

    /********************************************************************
     * Helper Functions for State Management and Simulation
     ********************************************************************/
    function cloneState(state) {
      return {
        board: state.board.map(cell => cell ? { ...cell } : null),
        movesX: [...state.movesX],
        movesO: [...state.movesO],
        currentPlayer: state.currentPlayer,
        gameOver: state.gameOver
      };
    }

    function getValidMoves(state) {
      let moves = [];
      for (let i = 0; i < state.board.length; i++) {
        let cell = state.board[i];
        if (cell === null || (cell.faded && cell.player !== state.currentPlayer)) {
          moves.push(i);
        }
      }
      return moves;
    }

    function checkWin(state) {
      for (const combo of winCombinations) {
        const [a, b, c] = combo;
        const cellA = state.board[a], cellB = state.board[b], cellC = state.board[c];
        if (cellA && cellB && cellC &&
            !cellA.faded && !cellB.faded && !cellC.faded &&
            cellA.player === cellB.player && cellB.player === cellC.player) {
          return cellA.player;
        }
      }
      return null;
    }

    function updateFading(state, player) {
      let moves = player === 'X' ? state.movesX : state.movesO;
      if (moves.length === 3) {
        const fadeIndex = moves[0];
        if (state.board[fadeIndex]) state.board[fadeIndex].faded = true;
      }
      let opponent = player === 'X' ? 'O' : 'X';
      let opponentMoves = opponent === 'X' ? state.movesX : state.movesO;
      if (opponentMoves.length >= 3) {
        const oppFadeIndex = opponentMoves[0];
        if (state.board[oppFadeIndex] && state.board[oppFadeIndex].faded) {
          state.board[oppFadeIndex] = null;
          opponentMoves.shift();
        }
      }
    }

    function simulateMakeMove(state, index) {
      const newState = cloneState(state);
      const cell = newState.board[index];
      if (cell === null) {
        newState.board[index] = { player: newState.currentPlayer, faded: false };
        if (newState.currentPlayer === 'X') {
          newState.movesX.push(index);
          updateFading(newState, 'X');
        } else {
          newState.movesO.push(index);
          updateFading(newState, 'O');
        }
      } else if (cell.faded && cell.player !== newState.currentPlayer) {
        newState.board[index] = { player: newState.currentPlayer, faded: false };
        if (newState.currentPlayer === 'X') {
          const pos = newState.movesO.indexOf(index);
          if (pos > -1) newState.movesO.splice(pos, 1);
          newState.movesX.push(index);
          updateFading(newState, 'X');
        } else {
          const pos = newState.movesX.indexOf(index);
          if (pos > -1) newState.movesX.splice(pos, 1);
          newState.movesO.push(index);
          updateFading(newState, 'O');
        }
      } else {
        return null;
      }
      if (checkWin(newState)) newState.gameOver = true;
      newState.currentPlayer = newState.currentPlayer === 'X' ? 'O' : 'X';
      return newState;
    }

    /********************************************************************
     * Minimax Algorithm for AI Move Calculation
     ********************************************************************/
    function minimax(state, depth, isMaximizing, alpha = -Infinity, beta = Infinity) {
      const winner = checkWin(state);
      if (winner === 'O') return 10 - depth;
      if (winner === 'X') return depth - 10;
      const validMoves = getValidMoves(state);
      if (validMoves.length === 0) return 0;

      if (isMaximizing) {
        let bestScore = -Infinity;
        for (const move of validMoves) {
          const nextState = simulateMakeMove(state, move);
          if (!nextState) continue;
          const score = minimax(nextState, depth + 1, false, alpha, beta);
          bestScore = Math.max(score, bestScore);
          alpha = Math.max(alpha, bestScore);
          if (beta <= alpha) break;
        }
        return bestScore;
      } else {
        let bestScore = Infinity;
        for (const move of validMoves) {
          const nextState = simulateMakeMove(state, move);
          if (!nextState) continue;
          const score = minimax(nextState, depth + 1, true, alpha, beta);
          bestScore = Math.min(score, bestScore);
          beta = Math.min(beta, bestScore);
          if (beta <= alpha) break;
        }
        return bestScore;
      }
    }

    function getBestMove() {
      let bestScore = -Infinity, bestMove = null;
      const validMoves = getValidMoves(gameState);
      for (const move of validMoves) {
        const simulatedState = simulateMakeMove(gameState, move);
        if (!simulatedState) continue;
        const score = minimax(simulatedState, 0, false);
        if (score > bestScore) {
          bestScore = score;
          bestMove = move;
        }
      }
      return bestMove;
    }

    /********************************************************************
     * Main Game Logic Functions
     ********************************************************************/
    function makeMove(index, isSimulation = false) {
      if (gameState.gameOver || (gameMode === 'ai' && gameState.currentPlayer === 'O' && !isSimulation)) return;
      if (!isSimulation) moveHistory.push(cloneState(gameState));

      const cell = gameState.board[index];
      if (cell === null || (cell.faded && cell.player !== gameState.currentPlayer)) {
        if (cell === null) {
          gameState.board[index] = { player: gameState.currentPlayer, faded: false };
          if (gameState.currentPlayer === 'X') {
            gameState.movesX.push(index);
            updateFading(gameState, 'X');
          } else {
            gameState.movesO.push(index);
            updateFading(gameState, 'O');
          }
        } else if (cell.faded && cell.player !== gameState.currentPlayer) {
          gameState.board[index] = { player: gameState.currentPlayer, faded: false };
          if (gameState.currentPlayer === 'X') {
            const pos = gameState.movesO.indexOf(index);
            if (pos > -1) gameState.movesO.splice(pos, 1);
            gameState.movesX.push(index);
            updateFading(gameState, 'X');
          } else {
            const pos = gameState.movesX.indexOf(index);
            if (pos > -1) gameState.movesX.splice(pos, 1);
            gameState.movesO.push(index);
            updateFading(gameState, 'O');
          }
        }
      } else return;
      
      gameState.currentPlayer = gameState.currentPlayer === 'X' ? 'O' : 'X';
      statusDiv.textContent = `Current Player: ${gameState.currentPlayer}`;
      updateCanvas();

      const winner = checkWin(gameState);
      if (winner) {
        statusDiv.textContent = `Player ${winner} wins!`;
        scores[winner]++;
        updateScoreBoard();
        gameState.gameOver = true;
        playSound(winSound);
        setTimeout(() => showGameOver(`Player ${winner} wins!`), 1000);
      } else if (!isSimulation && gameMode === 'ai' && gameState.currentPlayer === 'O') {
        aiMove();
      } else if (!isSimulation) {
        playSound(moveSound);
      }
    }

    function undoMove() {
      if (moveHistory.length === 0 || (gameMode === 'ai' && gameState.currentPlayer === 'O')) return;
      gameState = moveHistory.pop();
      statusDiv.textContent = `Current Player: ${gameState.currentPlayer}`;
      updateCanvas();
    }

    function resetGame() {
      gameState = {
        board: Array(9).fill(null),
        movesX: [],
        movesO: [],
        currentPlayer: 'X',
        gameOver: false
      };
      moveHistory = [];
      statusDiv.textContent = `Current Player: ${gameState.currentPlayer}`;
      updateCanvas();
    }

    /********************************************************************
     * UI and Canvas Drawing Functions
     ********************************************************************/
    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.lineWidth = 4;
      ctx.strokeStyle = isDarkMode ? '#fff' : '#333';
      ctx.beginPath();
      ctx.moveTo(100, 10);
      ctx.lineTo(100, 290);
      ctx.moveTo(200, 10);
      ctx.lineTo(200, 290);
      ctx.moveTo(10, 100);
      ctx.lineTo(290, 100);
      ctx.moveTo(10, 200);
      ctx.lineTo(290, 200);
      ctx.stroke();
    }

    function drawMoves() {
      for (let i = 0; i < 9; i++) {
        const cell = gameState.board[i];
        if (cell !== null) {
          const col = i % 3;
          const row = Math.floor(i / 3);
          const centerX = col * 100 + 50;
          const centerY = row * 100 + 50;
          ctx.save();
          ctx.globalAlpha = cell.faded ? 0.3 : 1.0;
          ctx.font = 'bold 60px Orbitron';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          const gradient = ctx.createLinearGradient(centerX - 25, centerY - 25, centerX + 25, centerY + 25);
          if (cell.player === 'X') {
            gradient.addColorStop(0, '#E74C3C');
            gradient.addColorStop(1, '#C0392B');
          } else {
            gradient.addColorStop(0, '#2ECC71');
            gradient.addColorStop(1, '#27AE60');
          }
          ctx.fillStyle = gradient;
          ctx.fillText(cell.player, centerX, centerY);
          ctx.restore();
        }
      }
    }

    function updateCanvas() {
      drawGrid();
      drawMoves();
    }

    function updateScoreBoard() {
      document.getElementById('scoreX').textContent = scores.X;
      document.getElementById('scoreO').textContent = scores.O;
    }

    function showGameOver(message) {
      const modal = document.getElementById('modeSelection');
      const content = modal.querySelector('.modal-content');
      content.innerHTML = `
        <h2>${message}</h2>
        <button class="button" onclick="selectMode('${gameMode}')">Play Again</button>
        <button class="button" onclick="showModeSelection()">Change Mode</button>
      `;
      modal.classList.add('active');
    }

    function showModeSelection() {
      document.getElementById('modeSelection').classList.add('active');
    }

    function showDifficultySelection() {
      document.getElementById('modeSelection').classList.remove('active');
      document.getElementById('difficultySelection').classList.add('active');
    }

    function selectMode(mode) {
      gameMode = mode;
      document.getElementById('modeSelection').classList.remove('active');
      resetGame();
    }

    function selectDifficulty(level) {
      difficulty = level;
      gameMode = 'ai';
      document.getElementById('difficultySelection').classList.remove('active');
      resetGame();
    }

    function toggleSettings() {
      document.getElementById('settingsModal').classList.add('active');
    }
    function hideSettings() {
      document.getElementById('settingsModal').classList.remove('active');
    }
    function toggleDarkMode() {
      isDarkMode = !isDarkMode;
      document.body.classList.toggle('dark-mode');
      updateCanvas();
    }
    function toggleSound() {
      soundEnabled = !soundEnabled;
      const soundButton = document.querySelector('.sound-toggle');
      soundButton.textContent = soundEnabled ? 'üîä' : 'üîá';
    }
    function playSound(sound) {
      if (soundEnabled) {
        sound.currentTime = 0;
        sound.play().catch(() => {});
      }
    }

    /********************************************************************
     * AI Move and Event Listeners
     ********************************************************************/
    function aiMove() {
      if (gameState.gameOver) return;
      const validMoves = getValidMoves(gameState);
      if (validMoves.length === 0) return;
      let move;
      switch (difficulty) {
        case 'easy':
          move = validMoves[Math.floor(Math.random() * validMoves.length)];
          break;
        case 'medium':
          move = Math.random() < 0.7 ? getBestMove() : validMoves[Math.floor(Math.random() * validMoves.length)];
          break;
        case 'hard':
          move = getBestMove();
          break;
      }
      // Reduced delay to mimic natural play
      setTimeout(() => makeMove(move), 300);
    }

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      const col = Math.floor(x / 100);
      const row = Math.floor(y / 100);
      const index = row * 3 + col;
      makeMove(index);
    });

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (touch.clientX - rect.left) * scaleX;
      const y = (touch.clientY - rect.top) * scaleY;
      const col = Math.floor(x / 100);
      const row = Math.floor(y / 100);
      const index = row * 3 + col;
      makeMove(index);
    });

    updateCanvas();
    showModeSelection();
  </script>
</body>
</html>
